/*
* Copyright (c) 2023, NVIDIA CORPORATION. All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a
* copy of this software and associated documentation files (the "Software"),
* to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense,
* and/or sell copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*/
#pragma once

#include "../dxvk_include.h"
#include "rtx_resources.h"
#include "dxvk_image.h"

namespace dxvk {

  class NGXWrapper;
  class DxvkCommandList;
  class DxvkBarrierSet;
  class DxvkContext;

  enum class DLSSProfile : uint32_t {
    UltraPerf = 0,
    MaxPerf,
    Balanced,
    MaxQuality,
    Auto,
    FullResolution,
    Invalid
  };

  const char* dlssProfileToString(DLSSProfile dlssProfile);

  class DxvkDLSS {
  public:
    enum class MotionVectorScale : uint32_t {
      Absolute,   ///< Motion vectors are provided in absolute screen space length (pixels).
      Relative,   ///< Motion vectors are provided in relative screen space length (pixels divided by screen width/height).
    };

    DxvkDLSS(DxvkDevice* device);
    ~DxvkDLSS();

    bool supportsDLSS() const;

    void setSetting(const uint32_t displaySize[2], const DLSSProfile profile, uint32_t outRenderSize[2]);
    // Gets the profile DLSS is currently using (the actual profile, not the settings-based one
    // which may be Auto for example).
    DLSSProfile getCurrentProfile() const;
    // Gets the input (the potentially lower resolution) size to be provided to DLSS.
    void getInputSize(uint32_t& width, uint32_t& height) const;
    // Gets the output (the potentially upscaled higher resolution) size to be provided to DLSS.
    void getOutputSize(uint32_t& width, uint32_t& height) const;

    void dispatch(
      Rc<DxvkCommandList> cmdList,
      Rc<DxvkDevice> device,
      Rc<RtxContext> ctx,
      DxvkBarrierSet& barriers,
      const Resources::RaytracingOutput& rtOutput,
      bool resetHistory = false);

    void showImguiSettings();

  private:
    static DLSSProfile getAutoProfile(uint32_t displayWidth, uint32_t displayHeight);

    void initializeDLSS(Rc<DxvkContext> pRenderContext, Rc<DxvkCommandList> cmdList);

    bool useDlssAutoExposure(Rc<DxvkDevice>& device) const;

    // Options
    bool                        mEnabled = true;
    DLSSProfile                 mProfile = DLSSProfile::Invalid;
    DLSSProfile                 mActualProfile = DLSSProfile::Invalid;
    MotionVectorScale           mMotionVectorScale = MotionVectorScale::Absolute;
    bool                        mIsHDR = true;
    float                       mPreExposure = 1.f;
    bool                        mAutoExposure = false;
    bool                        mInverseDepth = false;

    bool                        mRecreate = true;
    uint32_t                    mInputSize[2] = {};            ///< Input size in pixels.
    uint32_t                    mDLSSOutputSize[2] = {};       ///< DLSS output size in pixels.

    bool                        mBiasCurrentColorEnabled = true;

    DxvkDevice* m_device;
    Rc<DxvkShader> m_shader;
    Rc<DxvkBuffer> m_constants;
  };
}  // namespace dxvk
